# MarkLogic-UI-Resource (Muir) React Components

This library provides a set of React components useful for building applications backed by a MarkLogic database.

## Getting Started

### Installation

    npm install --save muir-react

or

    yarn add muir-react

### Implementation

If you are using these React components as stand-alone components, rather than as part of a Muir Project generated by the muir-cli, you will need to create a React container in your host application to pass the necessary props and callback functions to the Muir React components that you are importing. See the [`MLSearchContainer`](https://project.marklogic.com/repo/projects/NACW/repos/muir-react-template/browse/ui/src/containers/MLSearchContainer.js) in the Muir React UI Template for an example of doing this, using Redux modules. Also, look at [`App.js`](https://project.marklogic.com/repo/projects/NACW/repos/muir-react-template/browse/ui/src/App.js) and [`index.js`](https://project.marklogic.com/repo/projects/NACW/repos/muir-react-template/browse/ui/src/App.js) to see how selectors and actions are passed to `MLSearchContainer`.

## Components

### <DetailView />

This component provides a default view of a single document, together with some error handling. It can be customized:

#### Providing a custom detail page

<DetailView /> accepts a `template` prop that will override the default template when a document is successfully retrieved. It gets passed all the props that <DetailView /> itself received. Typically, you will write a React component to render those props as desired. It can then be passed to <DetailView /> like so:

    <DetailView template={myCustomDetailComponent} />

In many cases, in applications using Redux, <DetailView /> is the top-level 'dumb' component being wrapped by a 'smart' Redux container. In that case, you can add your template to `mapStateToProps` directly, as in this example:

```javascript
//...
import { DetailView } from 'muir-react';
import myDetailComponent from '../components/myDetailComponent';

import { actions, selectors } from 'ml-documents-redux';
import { bindSelectors } from '../utils/redux-utils';
const boundSelectors = bindSelectors(selectors, 'documents');

const mapStateToProps = (state, ownProps) => {
  const sel = boundSelectors;
  return {
    template: myDetailComponent,
    detail: sel.documentByUri(state, ownProps.uri),
    error: sel.errorByUri(state, ownProps.uri),
    contentType: sel.contentTypeByUri(state, ownProps.uri)
  };
};

//...
```

Or, you could allow the code consuming your container to pass in the template, and simply grab it from the `ownProps` argument from `mapStateToProps`.

### <SearchResults />

The default behavior of the SearchResults component is to offer a choice between a CardResult and a ListResult.

#### Customizing SearchResults

You can override the presentation of SearchResults by passing a `resultComponent` prop to <SearchResults />. Your component will receive a `result` prop and a `detailPath`. 

    <SearchResults resultComponent={myCustomSearchResult} />

Providing a `resultComponent` suppresses the out-of-the-box choice between components in the UI, and simply uses the provided `resultComponent`.

Note that you can also provide `resultComponent` to the higher-level <SearchView />, and it will be passed down to <SearchResults />.

You can use the <CardResult> in this library as a starting point, if you wish. It accepts `content` and `header` component props. For example:

```javascript
import { CardResult, SearchView, SearchSnippet} from 'muir-react';

const CustomSearchResultContent = ({result, detailPath}) => {
  return (
  <div>
    <p>You got a result!</p>
    <div className="ml-search-result-matches">
      {result.matches &&
        result.matches.map((match, index) => (
          <SearchSnippet match={match} key={index} />
        ))}
    </div>
  </div>
  )
};

const CustomSearchResult = (props) => {
  // suppress the header
  // add 'You got a result!' to each result
  return (
    <CardResult
      {...props}
      header={null}
      content={CustomSearchResultContent}
    />
  );
};
return () => (
  <SearchView
    {...this.props}
    detailPath="/detail/"
    resultComponent={CustomSearchResult}
  />
)
```

#### Customizing display when no results are found

You can also override the component displayed when no results are found, by passing in a component as a `noResults` prop:

```javascript
const customNoResults =  () => (
  <p>Truly, there are no results.</p>
)
<SearchResults noResults={customNoResults} />
```

### Storybook

We are creating a storybook for all the components present in this library. To see it, for the moment, clone this repository and run:

    npm run storybook

## Contributing

### Local Development of `muir-react`

You can use npm to link your local version of muir-react into an existing Muir React UI Application. First go into your `muir-react` directory and run the following to create a link on your machine from the name `muir-react` to this directory:

    cd {path-to-your-copy-of-muir-react}
    npm link

We need just one version of React. Because of the way the Node package manager (npm) can duplicate dependencies, this means we have to link your local `muir-react`'s version of React to your host application's.

    npm link {path-to-your-muir-project}/ui/node_modules/react

To complete the link, go into your Muir Project's `/ui` directory and run:

    cd {path-to-your-muir-project}/ui
    npm link muir-react

In order to see your changes to muir-react in your Muir Project, you will have to build muir-react:

    cd {path-to-your-copy-of-muir-react}
    npm run build

### Tests

    npm run test

To run the tests continuously as you change files:

    npm run test:watch

To get a report on test coverage:

    npm run test:coverage
    open coverage/html/index.html

### Stories

Best practice is to add a story for each component that gets exported from this library. We are using [Storybook](https://github.com/storybooks/storybook) for this, which is a form of live documentation. At least, there should be a story example for each supported state of the component. It is also possible to make interactive examples, though this is more work. See <Facets /> for an example.

Eventually, we may tie stories together with testing. This could follow the model [described in this article](https://medium.com/@mlthuret/building-a-react-components-living-documentation-using-react-storybook-5f11f0e7d23e).

To create a story for a component, save it as a new file ending with '.story.js'. See the codebase for examples.

### Code-Style and Linting

TODO: Describe ESLint, benefits of linting javascript, and the benefits of a common code-style. Also, how to set up editor-support.

TODO: We should enforce linting as part of the build.

## Optional Badges

TODO: Evaluate which to keep.

[![Travis][build-badge]][build]
[![npm package][npm-badge]][npm]
[![Coveralls][coveralls-badge]][coveralls]

[build-badge]: https://img.shields.io/travis/user/repo/master.png?style=flat-square
[build]: https://travis-ci.org/user/repo

[npm-badge]: https://img.shields.io/npm/v/npm-package.png?style=flat-square
[npm]: https://www.npmjs.org/package/npm-package

[coveralls-badge]: https://img.shields.io/coveralls/user/repo/master.png?style=flat-square
[coveralls]: https://coveralls.io/github/user/repo
